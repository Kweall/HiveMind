// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i hivemind/internal/storage.Storage -o storage_mock.go -n StorageMock -p mocks

import (
	"context"
	"hivemind/graph/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements mm_storage.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateComment          func(ctx context.Context, comment *model.Comment) (err error)
	funcCreateCommentOrigin    string
	inspectFuncCreateComment   func(ctx context.Context, comment *model.Comment)
	afterCreateCommentCounter  uint64
	beforeCreateCommentCounter uint64
	CreateCommentMock          mStorageMockCreateComment

	funcCreatePost          func(ctx context.Context, post *model.Post) (err error)
	funcCreatePostOrigin    string
	inspectFuncCreatePost   func(ctx context.Context, post *model.Post)
	afterCreatePostCounter  uint64
	beforeCreatePostCounter uint64
	CreatePostMock          mStorageMockCreatePost

	funcGetCommentsByPostID          func(ctx context.Context, postID string, limit int, offset int) (cpa1 []*model.Comment, err error)
	funcGetCommentsByPostIDOrigin    string
	inspectFuncGetCommentsByPostID   func(ctx context.Context, postID string, limit int, offset int)
	afterGetCommentsByPostIDCounter  uint64
	beforeGetCommentsByPostIDCounter uint64
	GetCommentsByPostIDMock          mStorageMockGetCommentsByPostID

	funcGetPostByID          func(ctx context.Context, id string) (pp1 *model.Post, err error)
	funcGetPostByIDOrigin    string
	inspectFuncGetPostByID   func(ctx context.Context, id string)
	afterGetPostByIDCounter  uint64
	beforeGetPostByIDCounter uint64
	GetPostByIDMock          mStorageMockGetPostByID

	funcGetPosts          func(ctx context.Context) (ppa1 []*model.Post, err error)
	funcGetPostsOrigin    string
	inspectFuncGetPosts   func(ctx context.Context)
	afterGetPostsCounter  uint64
	beforeGetPostsCounter uint64
	GetPostsMock          mStorageMockGetPosts

	funcGetReplies          func(ctx context.Context, parentID string, limit int, offset int) (cpa1 []*model.Comment, err error)
	funcGetRepliesOrigin    string
	inspectFuncGetReplies   func(ctx context.Context, parentID string, limit int, offset int)
	afterGetRepliesCounter  uint64
	beforeGetRepliesCounter uint64
	GetRepliesMock          mStorageMockGetReplies

	funcToggleComments          func(ctx context.Context, postID string, enabled bool, author string) (pp1 *model.Post, err error)
	funcToggleCommentsOrigin    string
	inspectFuncToggleComments   func(ctx context.Context, postID string, enabled bool, author string)
	afterToggleCommentsCounter  uint64
	beforeToggleCommentsCounter uint64
	ToggleCommentsMock          mStorageMockToggleComments
}

// NewStorageMock returns a mock for mm_storage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCommentMock = mStorageMockCreateComment{mock: m}
	m.CreateCommentMock.callArgs = []*StorageMockCreateCommentParams{}

	m.CreatePostMock = mStorageMockCreatePost{mock: m}
	m.CreatePostMock.callArgs = []*StorageMockCreatePostParams{}

	m.GetCommentsByPostIDMock = mStorageMockGetCommentsByPostID{mock: m}
	m.GetCommentsByPostIDMock.callArgs = []*StorageMockGetCommentsByPostIDParams{}

	m.GetPostByIDMock = mStorageMockGetPostByID{mock: m}
	m.GetPostByIDMock.callArgs = []*StorageMockGetPostByIDParams{}

	m.GetPostsMock = mStorageMockGetPosts{mock: m}
	m.GetPostsMock.callArgs = []*StorageMockGetPostsParams{}

	m.GetRepliesMock = mStorageMockGetReplies{mock: m}
	m.GetRepliesMock.callArgs = []*StorageMockGetRepliesParams{}

	m.ToggleCommentsMock = mStorageMockToggleComments{mock: m}
	m.ToggleCommentsMock.callArgs = []*StorageMockToggleCommentsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockCreateComment struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCreateCommentExpectation
	expectations       []*StorageMockCreateCommentExpectation

	callArgs []*StorageMockCreateCommentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCreateCommentExpectation specifies expectation struct of the Storage.CreateComment
type StorageMockCreateCommentExpectation struct {
	mock               *StorageMock
	params             *StorageMockCreateCommentParams
	paramPtrs          *StorageMockCreateCommentParamPtrs
	expectationOrigins StorageMockCreateCommentExpectationOrigins
	results            *StorageMockCreateCommentResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCreateCommentParams contains parameters of the Storage.CreateComment
type StorageMockCreateCommentParams struct {
	ctx     context.Context
	comment *model.Comment
}

// StorageMockCreateCommentParamPtrs contains pointers to parameters of the Storage.CreateComment
type StorageMockCreateCommentParamPtrs struct {
	ctx     *context.Context
	comment **model.Comment
}

// StorageMockCreateCommentResults contains results of the Storage.CreateComment
type StorageMockCreateCommentResults struct {
	err error
}

// StorageMockCreateCommentOrigins contains origins of expectations of the Storage.CreateComment
type StorageMockCreateCommentExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateComment *mStorageMockCreateComment) Optional() *mStorageMockCreateComment {
	mmCreateComment.optional = true
	return mmCreateComment
}

// Expect sets up expected params for Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) Expect(ctx context.Context, comment *model.Comment) *mStorageMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.paramPtrs != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by ExpectParams functions")
	}

	mmCreateComment.defaultExpectation.params = &StorageMockCreateCommentParams{ctx, comment}
	mmCreateComment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateComment.expectations {
		if minimock.Equal(e.params, mmCreateComment.defaultExpectation.params) {
			mmCreateComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateComment.defaultExpectation.params)
		}
	}

	return mmCreateComment
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) ExpectCtxParam1(ctx context.Context) *mStorageMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.params != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Expect")
	}

	if mmCreateComment.defaultExpectation.paramPtrs == nil {
		mmCreateComment.defaultExpectation.paramPtrs = &StorageMockCreateCommentParamPtrs{}
	}
	mmCreateComment.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateComment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateComment
}

// ExpectCommentParam2 sets up expected param comment for Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) ExpectCommentParam2(comment *model.Comment) *mStorageMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.params != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Expect")
	}

	if mmCreateComment.defaultExpectation.paramPtrs == nil {
		mmCreateComment.defaultExpectation.paramPtrs = &StorageMockCreateCommentParamPtrs{}
	}
	mmCreateComment.defaultExpectation.paramPtrs.comment = &comment
	mmCreateComment.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmCreateComment
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) Inspect(f func(ctx context.Context, comment *model.Comment)) *mStorageMockCreateComment {
	if mmCreateComment.mock.inspectFuncCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("Inspect function is already set for StorageMock.CreateComment")
	}

	mmCreateComment.mock.inspectFuncCreateComment = f

	return mmCreateComment
}

// Return sets up results that will be returned by Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) Return(err error) *StorageMock {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{mock: mmCreateComment.mock}
	}
	mmCreateComment.defaultExpectation.results = &StorageMockCreateCommentResults{err}
	mmCreateComment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateComment.mock
}

// Set uses given function f to mock the Storage.CreateComment method
func (mmCreateComment *mStorageMockCreateComment) Set(f func(ctx context.Context, comment *model.Comment) (err error)) *StorageMock {
	if mmCreateComment.defaultExpectation != nil {
		mmCreateComment.mock.t.Fatalf("Default expectation is already set for the Storage.CreateComment method")
	}

	if len(mmCreateComment.expectations) > 0 {
		mmCreateComment.mock.t.Fatalf("Some expectations are already set for the Storage.CreateComment method")
	}

	mmCreateComment.mock.funcCreateComment = f
	mmCreateComment.mock.funcCreateCommentOrigin = minimock.CallerInfo(1)
	return mmCreateComment.mock
}

// When sets expectation for the Storage.CreateComment which will trigger the result defined by the following
// Then helper
func (mmCreateComment *mStorageMockCreateComment) When(ctx context.Context, comment *model.Comment) *StorageMockCreateCommentExpectation {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	expectation := &StorageMockCreateCommentExpectation{
		mock:               mmCreateComment.mock,
		params:             &StorageMockCreateCommentParams{ctx, comment},
		expectationOrigins: StorageMockCreateCommentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateComment.expectations = append(mmCreateComment.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreateComment return parameters for the expectation previously defined by the When method
func (e *StorageMockCreateCommentExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCreateCommentResults{err}
	return e.mock
}

// Times sets number of times Storage.CreateComment should be invoked
func (mmCreateComment *mStorageMockCreateComment) Times(n uint64) *mStorageMockCreateComment {
	if n == 0 {
		mmCreateComment.mock.t.Fatalf("Times of StorageMock.CreateComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateComment.expectedInvocations, n)
	mmCreateComment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateComment
}

func (mmCreateComment *mStorageMockCreateComment) invocationsDone() bool {
	if len(mmCreateComment.expectations) == 0 && mmCreateComment.defaultExpectation == nil && mmCreateComment.mock.funcCreateComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateComment.mock.afterCreateCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateComment implements mm_storage.Storage
func (mmCreateComment *StorageMock) CreateComment(ctx context.Context, comment *model.Comment) (err error) {
	mm_atomic.AddUint64(&mmCreateComment.beforeCreateCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateComment.afterCreateCommentCounter, 1)

	mmCreateComment.t.Helper()

	if mmCreateComment.inspectFuncCreateComment != nil {
		mmCreateComment.inspectFuncCreateComment(ctx, comment)
	}

	mm_params := StorageMockCreateCommentParams{ctx, comment}

	// Record call args
	mmCreateComment.CreateCommentMock.mutex.Lock()
	mmCreateComment.CreateCommentMock.callArgs = append(mmCreateComment.CreateCommentMock.callArgs, &mm_params)
	mmCreateComment.CreateCommentMock.mutex.Unlock()

	for _, e := range mmCreateComment.CreateCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateComment.CreateCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateComment.CreateCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateComment.CreateCommentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateComment.CreateCommentMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCreateCommentParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateComment.t.Errorf("StorageMock.CreateComment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateComment.CreateCommentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmCreateComment.t.Errorf("StorageMock.CreateComment got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateComment.CreateCommentMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateComment.t.Errorf("StorageMock.CreateComment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateComment.CreateCommentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateComment.CreateCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateComment.t.Fatal("No results are set for the StorageMock.CreateComment")
		}
		return (*mm_results).err
	}
	if mmCreateComment.funcCreateComment != nil {
		return mmCreateComment.funcCreateComment(ctx, comment)
	}
	mmCreateComment.t.Fatalf("Unexpected call to StorageMock.CreateComment. %v %v", ctx, comment)
	return
}

// CreateCommentAfterCounter returns a count of finished StorageMock.CreateComment invocations
func (mmCreateComment *StorageMock) CreateCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComment.afterCreateCommentCounter)
}

// CreateCommentBeforeCounter returns a count of StorageMock.CreateComment invocations
func (mmCreateComment *StorageMock) CreateCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComment.beforeCreateCommentCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CreateComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateComment *mStorageMockCreateComment) Calls() []*StorageMockCreateCommentParams {
	mmCreateComment.mutex.RLock()

	argCopy := make([]*StorageMockCreateCommentParams, len(mmCreateComment.callArgs))
	copy(argCopy, mmCreateComment.callArgs)

	mmCreateComment.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCommentDone returns true if the count of the CreateComment invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreateCommentDone() bool {
	if m.CreateCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCommentMock.invocationsDone()
}

// MinimockCreateCommentInspect logs each unmet expectation
func (m *StorageMock) MinimockCreateCommentInspect() {
	for _, e := range m.CreateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCommentCounter := mm_atomic.LoadUint64(&m.afterCreateCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCommentMock.defaultExpectation != nil && afterCreateCommentCounter < 1 {
		if m.CreateCommentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s", m.CreateCommentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s with params: %#v", m.CreateCommentMock.defaultExpectation.expectationOrigins.origin, *m.CreateCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateComment != nil && afterCreateCommentCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s", m.funcCreateCommentOrigin)
	}

	if !m.CreateCommentMock.invocationsDone() && afterCreateCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CreateComment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCommentMock.expectedInvocations), m.CreateCommentMock.expectedInvocationsOrigin, afterCreateCommentCounter)
	}
}

type mStorageMockCreatePost struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCreatePostExpectation
	expectations       []*StorageMockCreatePostExpectation

	callArgs []*StorageMockCreatePostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCreatePostExpectation specifies expectation struct of the Storage.CreatePost
type StorageMockCreatePostExpectation struct {
	mock               *StorageMock
	params             *StorageMockCreatePostParams
	paramPtrs          *StorageMockCreatePostParamPtrs
	expectationOrigins StorageMockCreatePostExpectationOrigins
	results            *StorageMockCreatePostResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCreatePostParams contains parameters of the Storage.CreatePost
type StorageMockCreatePostParams struct {
	ctx  context.Context
	post *model.Post
}

// StorageMockCreatePostParamPtrs contains pointers to parameters of the Storage.CreatePost
type StorageMockCreatePostParamPtrs struct {
	ctx  *context.Context
	post **model.Post
}

// StorageMockCreatePostResults contains results of the Storage.CreatePost
type StorageMockCreatePostResults struct {
	err error
}

// StorageMockCreatePostOrigins contains origins of expectations of the Storage.CreatePost
type StorageMockCreatePostExpectationOrigins struct {
	origin     string
	originCtx  string
	originPost string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePost *mStorageMockCreatePost) Optional() *mStorageMockCreatePost {
	mmCreatePost.optional = true
	return mmCreatePost
}

// Expect sets up expected params for Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) Expect(ctx context.Context, post *model.Post) *mStorageMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.paramPtrs != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by ExpectParams functions")
	}

	mmCreatePost.defaultExpectation.params = &StorageMockCreatePostParams{ctx, post}
	mmCreatePost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePost.expectations {
		if minimock.Equal(e.params, mmCreatePost.defaultExpectation.params) {
			mmCreatePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePost.defaultExpectation.params)
		}
	}

	return mmCreatePost
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) ExpectCtxParam1(ctx context.Context) *mStorageMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &StorageMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePost.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePost
}

// ExpectPostParam2 sets up expected param post for Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) ExpectPostParam2(post *model.Post) *mStorageMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &StorageMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.post = &post
	mmCreatePost.defaultExpectation.expectationOrigins.originPost = minimock.CallerInfo(1)

	return mmCreatePost
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) Inspect(f func(ctx context.Context, post *model.Post)) *mStorageMockCreatePost {
	if mmCreatePost.mock.inspectFuncCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("Inspect function is already set for StorageMock.CreatePost")
	}

	mmCreatePost.mock.inspectFuncCreatePost = f

	return mmCreatePost
}

// Return sets up results that will be returned by Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) Return(err error) *StorageMock {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{mock: mmCreatePost.mock}
	}
	mmCreatePost.defaultExpectation.results = &StorageMockCreatePostResults{err}
	mmCreatePost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePost.mock
}

// Set uses given function f to mock the Storage.CreatePost method
func (mmCreatePost *mStorageMockCreatePost) Set(f func(ctx context.Context, post *model.Post) (err error)) *StorageMock {
	if mmCreatePost.defaultExpectation != nil {
		mmCreatePost.mock.t.Fatalf("Default expectation is already set for the Storage.CreatePost method")
	}

	if len(mmCreatePost.expectations) > 0 {
		mmCreatePost.mock.t.Fatalf("Some expectations are already set for the Storage.CreatePost method")
	}

	mmCreatePost.mock.funcCreatePost = f
	mmCreatePost.mock.funcCreatePostOrigin = minimock.CallerInfo(1)
	return mmCreatePost.mock
}

// When sets expectation for the Storage.CreatePost which will trigger the result defined by the following
// Then helper
func (mmCreatePost *mStorageMockCreatePost) When(ctx context.Context, post *model.Post) *StorageMockCreatePostExpectation {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	expectation := &StorageMockCreatePostExpectation{
		mock:               mmCreatePost.mock,
		params:             &StorageMockCreatePostParams{ctx, post},
		expectationOrigins: StorageMockCreatePostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePost.expectations = append(mmCreatePost.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreatePost return parameters for the expectation previously defined by the When method
func (e *StorageMockCreatePostExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockCreatePostResults{err}
	return e.mock
}

// Times sets number of times Storage.CreatePost should be invoked
func (mmCreatePost *mStorageMockCreatePost) Times(n uint64) *mStorageMockCreatePost {
	if n == 0 {
		mmCreatePost.mock.t.Fatalf("Times of StorageMock.CreatePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePost.expectedInvocations, n)
	mmCreatePost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePost
}

func (mmCreatePost *mStorageMockCreatePost) invocationsDone() bool {
	if len(mmCreatePost.expectations) == 0 && mmCreatePost.defaultExpectation == nil && mmCreatePost.mock.funcCreatePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePost.mock.afterCreatePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePost implements mm_storage.Storage
func (mmCreatePost *StorageMock) CreatePost(ctx context.Context, post *model.Post) (err error) {
	mm_atomic.AddUint64(&mmCreatePost.beforeCreatePostCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePost.afterCreatePostCounter, 1)

	mmCreatePost.t.Helper()

	if mmCreatePost.inspectFuncCreatePost != nil {
		mmCreatePost.inspectFuncCreatePost(ctx, post)
	}

	mm_params := StorageMockCreatePostParams{ctx, post}

	// Record call args
	mmCreatePost.CreatePostMock.mutex.Lock()
	mmCreatePost.CreatePostMock.callArgs = append(mmCreatePost.CreatePostMock.callArgs, &mm_params)
	mmCreatePost.CreatePostMock.mutex.Unlock()

	for _, e := range mmCreatePost.CreatePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePost.CreatePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePost.CreatePostMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePost.CreatePostMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePost.CreatePostMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCreatePostParams{ctx, post}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePost.t.Errorf("StorageMock.CreatePost got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.post != nil && !minimock.Equal(*mm_want_ptrs.post, mm_got.post) {
				mmCreatePost.t.Errorf("StorageMock.CreatePost got unexpected parameter post, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.originPost, *mm_want_ptrs.post, mm_got.post, minimock.Diff(*mm_want_ptrs.post, mm_got.post))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePost.t.Errorf("StorageMock.CreatePost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePost.CreatePostMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePost.t.Fatal("No results are set for the StorageMock.CreatePost")
		}
		return (*mm_results).err
	}
	if mmCreatePost.funcCreatePost != nil {
		return mmCreatePost.funcCreatePost(ctx, post)
	}
	mmCreatePost.t.Fatalf("Unexpected call to StorageMock.CreatePost. %v %v", ctx, post)
	return
}

// CreatePostAfterCounter returns a count of finished StorageMock.CreatePost invocations
func (mmCreatePost *StorageMock) CreatePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.afterCreatePostCounter)
}

// CreatePostBeforeCounter returns a count of StorageMock.CreatePost invocations
func (mmCreatePost *StorageMock) CreatePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.beforeCreatePostCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CreatePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePost *mStorageMockCreatePost) Calls() []*StorageMockCreatePostParams {
	mmCreatePost.mutex.RLock()

	argCopy := make([]*StorageMockCreatePostParams, len(mmCreatePost.callArgs))
	copy(argCopy, mmCreatePost.callArgs)

	mmCreatePost.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePostDone returns true if the count of the CreatePost invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreatePostDone() bool {
	if m.CreatePostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePostMock.invocationsDone()
}

// MinimockCreatePostInspect logs each unmet expectation
func (m *StorageMock) MinimockCreatePostInspect() {
	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePostCounter := mm_atomic.LoadUint64(&m.afterCreatePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePostMock.defaultExpectation != nil && afterCreatePostCounter < 1 {
		if m.CreatePostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s", m.CreatePostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s with params: %#v", m.CreatePostMock.defaultExpectation.expectationOrigins.origin, *m.CreatePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePost != nil && afterCreatePostCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s", m.funcCreatePostOrigin)
	}

	if !m.CreatePostMock.invocationsDone() && afterCreatePostCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CreatePost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePostMock.expectedInvocations), m.CreatePostMock.expectedInvocationsOrigin, afterCreatePostCounter)
	}
}

type mStorageMockGetCommentsByPostID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetCommentsByPostIDExpectation
	expectations       []*StorageMockGetCommentsByPostIDExpectation

	callArgs []*StorageMockGetCommentsByPostIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetCommentsByPostIDExpectation specifies expectation struct of the Storage.GetCommentsByPostID
type StorageMockGetCommentsByPostIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetCommentsByPostIDParams
	paramPtrs          *StorageMockGetCommentsByPostIDParamPtrs
	expectationOrigins StorageMockGetCommentsByPostIDExpectationOrigins
	results            *StorageMockGetCommentsByPostIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetCommentsByPostIDParams contains parameters of the Storage.GetCommentsByPostID
type StorageMockGetCommentsByPostIDParams struct {
	ctx    context.Context
	postID string
	limit  int
	offset int
}

// StorageMockGetCommentsByPostIDParamPtrs contains pointers to parameters of the Storage.GetCommentsByPostID
type StorageMockGetCommentsByPostIDParamPtrs struct {
	ctx    *context.Context
	postID *string
	limit  *int
	offset *int
}

// StorageMockGetCommentsByPostIDResults contains results of the Storage.GetCommentsByPostID
type StorageMockGetCommentsByPostIDResults struct {
	cpa1 []*model.Comment
	err  error
}

// StorageMockGetCommentsByPostIDOrigins contains origins of expectations of the Storage.GetCommentsByPostID
type StorageMockGetCommentsByPostIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originPostID string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Optional() *mStorageMockGetCommentsByPostID {
	mmGetCommentsByPostID.optional = true
	return mmGetCommentsByPostID
}

// Expect sets up expected params for Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Expect(ctx context.Context, postID string, limit int, offset int) *mStorageMockGetCommentsByPostID {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	if mmGetCommentsByPostID.defaultExpectation == nil {
		mmGetCommentsByPostID.defaultExpectation = &StorageMockGetCommentsByPostIDExpectation{}
	}

	if mmGetCommentsByPostID.defaultExpectation.paramPtrs != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by ExpectParams functions")
	}

	mmGetCommentsByPostID.defaultExpectation.params = &StorageMockGetCommentsByPostIDParams{ctx, postID, limit, offset}
	mmGetCommentsByPostID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommentsByPostID.expectations {
		if minimock.Equal(e.params, mmGetCommentsByPostID.defaultExpectation.params) {
			mmGetCommentsByPostID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentsByPostID.defaultExpectation.params)
		}
	}

	return mmGetCommentsByPostID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) ExpectCtxParam1(ctx context.Context) *mStorageMockGetCommentsByPostID {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	if mmGetCommentsByPostID.defaultExpectation == nil {
		mmGetCommentsByPostID.defaultExpectation = &StorageMockGetCommentsByPostIDExpectation{}
	}

	if mmGetCommentsByPostID.defaultExpectation.params != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Expect")
	}

	if mmGetCommentsByPostID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDParamPtrs{}
	}
	mmGetCommentsByPostID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCommentsByPostID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCommentsByPostID
}

// ExpectPostIDParam2 sets up expected param postID for Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) ExpectPostIDParam2(postID string) *mStorageMockGetCommentsByPostID {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	if mmGetCommentsByPostID.defaultExpectation == nil {
		mmGetCommentsByPostID.defaultExpectation = &StorageMockGetCommentsByPostIDExpectation{}
	}

	if mmGetCommentsByPostID.defaultExpectation.params != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Expect")
	}

	if mmGetCommentsByPostID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDParamPtrs{}
	}
	mmGetCommentsByPostID.defaultExpectation.paramPtrs.postID = &postID
	mmGetCommentsByPostID.defaultExpectation.expectationOrigins.originPostID = minimock.CallerInfo(1)

	return mmGetCommentsByPostID
}

// ExpectLimitParam3 sets up expected param limit for Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) ExpectLimitParam3(limit int) *mStorageMockGetCommentsByPostID {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	if mmGetCommentsByPostID.defaultExpectation == nil {
		mmGetCommentsByPostID.defaultExpectation = &StorageMockGetCommentsByPostIDExpectation{}
	}

	if mmGetCommentsByPostID.defaultExpectation.params != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Expect")
	}

	if mmGetCommentsByPostID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDParamPtrs{}
	}
	mmGetCommentsByPostID.defaultExpectation.paramPtrs.limit = &limit
	mmGetCommentsByPostID.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetCommentsByPostID
}

// ExpectOffsetParam4 sets up expected param offset for Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) ExpectOffsetParam4(offset int) *mStorageMockGetCommentsByPostID {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	if mmGetCommentsByPostID.defaultExpectation == nil {
		mmGetCommentsByPostID.defaultExpectation = &StorageMockGetCommentsByPostIDExpectation{}
	}

	if mmGetCommentsByPostID.defaultExpectation.params != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Expect")
	}

	if mmGetCommentsByPostID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDParamPtrs{}
	}
	mmGetCommentsByPostID.defaultExpectation.paramPtrs.offset = &offset
	mmGetCommentsByPostID.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetCommentsByPostID
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Inspect(f func(ctx context.Context, postID string, limit int, offset int)) *mStorageMockGetCommentsByPostID {
	if mmGetCommentsByPostID.mock.inspectFuncGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("Inspect function is already set for StorageMock.GetCommentsByPostID")
	}

	mmGetCommentsByPostID.mock.inspectFuncGetCommentsByPostID = f

	return mmGetCommentsByPostID
}

// Return sets up results that will be returned by Storage.GetCommentsByPostID
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Return(cpa1 []*model.Comment, err error) *StorageMock {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	if mmGetCommentsByPostID.defaultExpectation == nil {
		mmGetCommentsByPostID.defaultExpectation = &StorageMockGetCommentsByPostIDExpectation{mock: mmGetCommentsByPostID.mock}
	}
	mmGetCommentsByPostID.defaultExpectation.results = &StorageMockGetCommentsByPostIDResults{cpa1, err}
	mmGetCommentsByPostID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByPostID.mock
}

// Set uses given function f to mock the Storage.GetCommentsByPostID method
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Set(f func(ctx context.Context, postID string, limit int, offset int) (cpa1 []*model.Comment, err error)) *StorageMock {
	if mmGetCommentsByPostID.defaultExpectation != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("Default expectation is already set for the Storage.GetCommentsByPostID method")
	}

	if len(mmGetCommentsByPostID.expectations) > 0 {
		mmGetCommentsByPostID.mock.t.Fatalf("Some expectations are already set for the Storage.GetCommentsByPostID method")
	}

	mmGetCommentsByPostID.mock.funcGetCommentsByPostID = f
	mmGetCommentsByPostID.mock.funcGetCommentsByPostIDOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByPostID.mock
}

// When sets expectation for the Storage.GetCommentsByPostID which will trigger the result defined by the following
// Then helper
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) When(ctx context.Context, postID string, limit int, offset int) *StorageMockGetCommentsByPostIDExpectation {
	if mmGetCommentsByPostID.mock.funcGetCommentsByPostID != nil {
		mmGetCommentsByPostID.mock.t.Fatalf("StorageMock.GetCommentsByPostID mock is already set by Set")
	}

	expectation := &StorageMockGetCommentsByPostIDExpectation{
		mock:               mmGetCommentsByPostID.mock,
		params:             &StorageMockGetCommentsByPostIDParams{ctx, postID, limit, offset},
		expectationOrigins: StorageMockGetCommentsByPostIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommentsByPostID.expectations = append(mmGetCommentsByPostID.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetCommentsByPostID return parameters for the expectation previously defined by the When method
func (e *StorageMockGetCommentsByPostIDExpectation) Then(cpa1 []*model.Comment, err error) *StorageMock {
	e.results = &StorageMockGetCommentsByPostIDResults{cpa1, err}
	return e.mock
}

// Times sets number of times Storage.GetCommentsByPostID should be invoked
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Times(n uint64) *mStorageMockGetCommentsByPostID {
	if n == 0 {
		mmGetCommentsByPostID.mock.t.Fatalf("Times of StorageMock.GetCommentsByPostID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentsByPostID.expectedInvocations, n)
	mmGetCommentsByPostID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByPostID
}

func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) invocationsDone() bool {
	if len(mmGetCommentsByPostID.expectations) == 0 && mmGetCommentsByPostID.defaultExpectation == nil && mmGetCommentsByPostID.mock.funcGetCommentsByPostID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentsByPostID.mock.afterGetCommentsByPostIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentsByPostID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentsByPostID implements mm_storage.Storage
func (mmGetCommentsByPostID *StorageMock) GetCommentsByPostID(ctx context.Context, postID string, limit int, offset int) (cpa1 []*model.Comment, err error) {
	mm_atomic.AddUint64(&mmGetCommentsByPostID.beforeGetCommentsByPostIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentsByPostID.afterGetCommentsByPostIDCounter, 1)

	mmGetCommentsByPostID.t.Helper()

	if mmGetCommentsByPostID.inspectFuncGetCommentsByPostID != nil {
		mmGetCommentsByPostID.inspectFuncGetCommentsByPostID(ctx, postID, limit, offset)
	}

	mm_params := StorageMockGetCommentsByPostIDParams{ctx, postID, limit, offset}

	// Record call args
	mmGetCommentsByPostID.GetCommentsByPostIDMock.mutex.Lock()
	mmGetCommentsByPostID.GetCommentsByPostIDMock.callArgs = append(mmGetCommentsByPostID.GetCommentsByPostIDMock.callArgs, &mm_params)
	mmGetCommentsByPostID.GetCommentsByPostIDMock.mutex.Unlock()

	for _, e := range mmGetCommentsByPostID.GetCommentsByPostIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetCommentsByPostIDParams{ctx, postID, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentsByPostID.t.Errorf("StorageMock.GetCommentsByPostID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmGetCommentsByPostID.t.Errorf("StorageMock.GetCommentsByPostID got unexpected parameter postID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.expectationOrigins.originPostID, *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetCommentsByPostID.t.Errorf("StorageMock.GetCommentsByPostID got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetCommentsByPostID.t.Errorf("StorageMock.GetCommentsByPostID got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentsByPostID.t.Errorf("StorageMock.GetCommentsByPostID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentsByPostID.GetCommentsByPostIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentsByPostID.t.Fatal("No results are set for the StorageMock.GetCommentsByPostID")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetCommentsByPostID.funcGetCommentsByPostID != nil {
		return mmGetCommentsByPostID.funcGetCommentsByPostID(ctx, postID, limit, offset)
	}
	mmGetCommentsByPostID.t.Fatalf("Unexpected call to StorageMock.GetCommentsByPostID. %v %v %v %v", ctx, postID, limit, offset)
	return
}

// GetCommentsByPostIDAfterCounter returns a count of finished StorageMock.GetCommentsByPostID invocations
func (mmGetCommentsByPostID *StorageMock) GetCommentsByPostIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByPostID.afterGetCommentsByPostIDCounter)
}

// GetCommentsByPostIDBeforeCounter returns a count of StorageMock.GetCommentsByPostID invocations
func (mmGetCommentsByPostID *StorageMock) GetCommentsByPostIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByPostID.beforeGetCommentsByPostIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetCommentsByPostID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentsByPostID *mStorageMockGetCommentsByPostID) Calls() []*StorageMockGetCommentsByPostIDParams {
	mmGetCommentsByPostID.mutex.RLock()

	argCopy := make([]*StorageMockGetCommentsByPostIDParams, len(mmGetCommentsByPostID.callArgs))
	copy(argCopy, mmGetCommentsByPostID.callArgs)

	mmGetCommentsByPostID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsByPostIDDone returns true if the count of the GetCommentsByPostID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetCommentsByPostIDDone() bool {
	if m.GetCommentsByPostIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentsByPostIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsByPostIDMock.invocationsDone()
}

// MinimockGetCommentsByPostIDInspect logs each unmet expectation
func (m *StorageMock) MinimockGetCommentsByPostIDInspect() {
	for _, e := range m.GetCommentsByPostIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByPostID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommentsByPostIDCounter := mm_atomic.LoadUint64(&m.afterGetCommentsByPostIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsByPostIDMock.defaultExpectation != nil && afterGetCommentsByPostIDCounter < 1 {
		if m.GetCommentsByPostIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByPostID at\n%s", m.GetCommentsByPostIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByPostID at\n%s with params: %#v", m.GetCommentsByPostIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCommentsByPostIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentsByPostID != nil && afterGetCommentsByPostIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetCommentsByPostID at\n%s", m.funcGetCommentsByPostIDOrigin)
	}

	if !m.GetCommentsByPostIDMock.invocationsDone() && afterGetCommentsByPostIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetCommentsByPostID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsByPostIDMock.expectedInvocations), m.GetCommentsByPostIDMock.expectedInvocationsOrigin, afterGetCommentsByPostIDCounter)
	}
}

type mStorageMockGetPostByID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetPostByIDExpectation
	expectations       []*StorageMockGetPostByIDExpectation

	callArgs []*StorageMockGetPostByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetPostByIDExpectation specifies expectation struct of the Storage.GetPostByID
type StorageMockGetPostByIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetPostByIDParams
	paramPtrs          *StorageMockGetPostByIDParamPtrs
	expectationOrigins StorageMockGetPostByIDExpectationOrigins
	results            *StorageMockGetPostByIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetPostByIDParams contains parameters of the Storage.GetPostByID
type StorageMockGetPostByIDParams struct {
	ctx context.Context
	id  string
}

// StorageMockGetPostByIDParamPtrs contains pointers to parameters of the Storage.GetPostByID
type StorageMockGetPostByIDParamPtrs struct {
	ctx *context.Context
	id  *string
}

// StorageMockGetPostByIDResults contains results of the Storage.GetPostByID
type StorageMockGetPostByIDResults struct {
	pp1 *model.Post
	err error
}

// StorageMockGetPostByIDOrigins contains origins of expectations of the Storage.GetPostByID
type StorageMockGetPostByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPostByID *mStorageMockGetPostByID) Optional() *mStorageMockGetPostByID {
	mmGetPostByID.optional = true
	return mmGetPostByID
}

// Expect sets up expected params for Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) Expect(ctx context.Context, id string) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.paramPtrs != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by ExpectParams functions")
	}

	mmGetPostByID.defaultExpectation.params = &StorageMockGetPostByIDParams{ctx, id}
	mmGetPostByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPostByID.expectations {
		if minimock.Equal(e.params, mmGetPostByID.defaultExpectation.params) {
			mmGetPostByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostByID.defaultExpectation.params)
		}
	}

	return mmGetPostByID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) ExpectCtxParam1(ctx context.Context) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.params != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Expect")
	}

	if mmGetPostByID.defaultExpectation.paramPtrs == nil {
		mmGetPostByID.defaultExpectation.paramPtrs = &StorageMockGetPostByIDParamPtrs{}
	}
	mmGetPostByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPostByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPostByID
}

// ExpectIdParam2 sets up expected param id for Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) ExpectIdParam2(id string) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.params != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Expect")
	}

	if mmGetPostByID.defaultExpectation.paramPtrs == nil {
		mmGetPostByID.defaultExpectation.paramPtrs = &StorageMockGetPostByIDParamPtrs{}
	}
	mmGetPostByID.defaultExpectation.paramPtrs.id = &id
	mmGetPostByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPostByID
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) Inspect(f func(ctx context.Context, id string)) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.inspectFuncGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPostByID")
	}

	mmGetPostByID.mock.inspectFuncGetPostByID = f

	return mmGetPostByID
}

// Return sets up results that will be returned by Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) Return(pp1 *model.Post, err error) *StorageMock {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{mock: mmGetPostByID.mock}
	}
	mmGetPostByID.defaultExpectation.results = &StorageMockGetPostByIDResults{pp1, err}
	mmGetPostByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPostByID.mock
}

// Set uses given function f to mock the Storage.GetPostByID method
func (mmGetPostByID *mStorageMockGetPostByID) Set(f func(ctx context.Context, id string) (pp1 *model.Post, err error)) *StorageMock {
	if mmGetPostByID.defaultExpectation != nil {
		mmGetPostByID.mock.t.Fatalf("Default expectation is already set for the Storage.GetPostByID method")
	}

	if len(mmGetPostByID.expectations) > 0 {
		mmGetPostByID.mock.t.Fatalf("Some expectations are already set for the Storage.GetPostByID method")
	}

	mmGetPostByID.mock.funcGetPostByID = f
	mmGetPostByID.mock.funcGetPostByIDOrigin = minimock.CallerInfo(1)
	return mmGetPostByID.mock
}

// When sets expectation for the Storage.GetPostByID which will trigger the result defined by the following
// Then helper
func (mmGetPostByID *mStorageMockGetPostByID) When(ctx context.Context, id string) *StorageMockGetPostByIDExpectation {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	expectation := &StorageMockGetPostByIDExpectation{
		mock:               mmGetPostByID.mock,
		params:             &StorageMockGetPostByIDParams{ctx, id},
		expectationOrigins: StorageMockGetPostByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPostByID.expectations = append(mmGetPostByID.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPostByID return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPostByIDExpectation) Then(pp1 *model.Post, err error) *StorageMock {
	e.results = &StorageMockGetPostByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Storage.GetPostByID should be invoked
func (mmGetPostByID *mStorageMockGetPostByID) Times(n uint64) *mStorageMockGetPostByID {
	if n == 0 {
		mmGetPostByID.mock.t.Fatalf("Times of StorageMock.GetPostByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPostByID.expectedInvocations, n)
	mmGetPostByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPostByID
}

func (mmGetPostByID *mStorageMockGetPostByID) invocationsDone() bool {
	if len(mmGetPostByID.expectations) == 0 && mmGetPostByID.defaultExpectation == nil && mmGetPostByID.mock.funcGetPostByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPostByID.mock.afterGetPostByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPostByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPostByID implements mm_storage.Storage
func (mmGetPostByID *StorageMock) GetPostByID(ctx context.Context, id string) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmGetPostByID.beforeGetPostByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostByID.afterGetPostByIDCounter, 1)

	mmGetPostByID.t.Helper()

	if mmGetPostByID.inspectFuncGetPostByID != nil {
		mmGetPostByID.inspectFuncGetPostByID(ctx, id)
	}

	mm_params := StorageMockGetPostByIDParams{ctx, id}

	// Record call args
	mmGetPostByID.GetPostByIDMock.mutex.Lock()
	mmGetPostByID.GetPostByIDMock.callArgs = append(mmGetPostByID.GetPostByIDMock.callArgs, &mm_params)
	mmGetPostByID.GetPostByIDMock.mutex.Unlock()

	for _, e := range mmGetPostByID.GetPostByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPostByID.GetPostByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostByID.GetPostByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostByID.GetPostByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPostByID.GetPostByIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetPostByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPostByID.t.Errorf("StorageMock.GetPostByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPostByID.t.Errorf("StorageMock.GetPostByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostByID.t.Errorf("StorageMock.GetPostByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostByID.GetPostByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostByID.t.Fatal("No results are set for the StorageMock.GetPostByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPostByID.funcGetPostByID != nil {
		return mmGetPostByID.funcGetPostByID(ctx, id)
	}
	mmGetPostByID.t.Fatalf("Unexpected call to StorageMock.GetPostByID. %v %v", ctx, id)
	return
}

// GetPostByIDAfterCounter returns a count of finished StorageMock.GetPostByID invocations
func (mmGetPostByID *StorageMock) GetPostByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostByID.afterGetPostByIDCounter)
}

// GetPostByIDBeforeCounter returns a count of StorageMock.GetPostByID invocations
func (mmGetPostByID *StorageMock) GetPostByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostByID.beforeGetPostByIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPostByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostByID *mStorageMockGetPostByID) Calls() []*StorageMockGetPostByIDParams {
	mmGetPostByID.mutex.RLock()

	argCopy := make([]*StorageMockGetPostByIDParams, len(mmGetPostByID.callArgs))
	copy(argCopy, mmGetPostByID.callArgs)

	mmGetPostByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostByIDDone returns true if the count of the GetPostByID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPostByIDDone() bool {
	if m.GetPostByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostByIDMock.invocationsDone()
}

// MinimockGetPostByIDInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPostByIDInspect() {
	for _, e := range m.GetPostByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPostByIDCounter := mm_atomic.LoadUint64(&m.afterGetPostByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostByIDMock.defaultExpectation != nil && afterGetPostByIDCounter < 1 {
		if m.GetPostByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s", m.GetPostByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s with params: %#v", m.GetPostByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPostByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostByID != nil && afterGetPostByIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s", m.funcGetPostByIDOrigin)
	}

	if !m.GetPostByIDMock.invocationsDone() && afterGetPostByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetPostByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostByIDMock.expectedInvocations), m.GetPostByIDMock.expectedInvocationsOrigin, afterGetPostByIDCounter)
	}
}

type mStorageMockGetPosts struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetPostsExpectation
	expectations       []*StorageMockGetPostsExpectation

	callArgs []*StorageMockGetPostsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetPostsExpectation specifies expectation struct of the Storage.GetPosts
type StorageMockGetPostsExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetPostsParams
	paramPtrs          *StorageMockGetPostsParamPtrs
	expectationOrigins StorageMockGetPostsExpectationOrigins
	results            *StorageMockGetPostsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetPostsParams contains parameters of the Storage.GetPosts
type StorageMockGetPostsParams struct {
	ctx context.Context
}

// StorageMockGetPostsParamPtrs contains pointers to parameters of the Storage.GetPosts
type StorageMockGetPostsParamPtrs struct {
	ctx *context.Context
}

// StorageMockGetPostsResults contains results of the Storage.GetPosts
type StorageMockGetPostsResults struct {
	ppa1 []*model.Post
	err  error
}

// StorageMockGetPostsOrigins contains origins of expectations of the Storage.GetPosts
type StorageMockGetPostsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPosts *mStorageMockGetPosts) Optional() *mStorageMockGetPosts {
	mmGetPosts.optional = true
	return mmGetPosts
}

// Expect sets up expected params for Storage.GetPosts
func (mmGetPosts *mStorageMockGetPosts) Expect(ctx context.Context) *mStorageMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("StorageMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &StorageMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.paramPtrs != nil {
		mmGetPosts.mock.t.Fatalf("StorageMock.GetPosts mock is already set by ExpectParams functions")
	}

	mmGetPosts.defaultExpectation.params = &StorageMockGetPostsParams{ctx}
	mmGetPosts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPosts.expectations {
		if minimock.Equal(e.params, mmGetPosts.defaultExpectation.params) {
			mmGetPosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPosts.defaultExpectation.params)
		}
	}

	return mmGetPosts
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetPosts
func (mmGetPosts *mStorageMockGetPosts) ExpectCtxParam1(ctx context.Context) *mStorageMockGetPosts {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("StorageMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &StorageMockGetPostsExpectation{}
	}

	if mmGetPosts.defaultExpectation.params != nil {
		mmGetPosts.mock.t.Fatalf("StorageMock.GetPosts mock is already set by Expect")
	}

	if mmGetPosts.defaultExpectation.paramPtrs == nil {
		mmGetPosts.defaultExpectation.paramPtrs = &StorageMockGetPostsParamPtrs{}
	}
	mmGetPosts.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPosts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPosts
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPosts
func (mmGetPosts *mStorageMockGetPosts) Inspect(f func(ctx context.Context)) *mStorageMockGetPosts {
	if mmGetPosts.mock.inspectFuncGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPosts")
	}

	mmGetPosts.mock.inspectFuncGetPosts = f

	return mmGetPosts
}

// Return sets up results that will be returned by Storage.GetPosts
func (mmGetPosts *mStorageMockGetPosts) Return(ppa1 []*model.Post, err error) *StorageMock {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("StorageMock.GetPosts mock is already set by Set")
	}

	if mmGetPosts.defaultExpectation == nil {
		mmGetPosts.defaultExpectation = &StorageMockGetPostsExpectation{mock: mmGetPosts.mock}
	}
	mmGetPosts.defaultExpectation.results = &StorageMockGetPostsResults{ppa1, err}
	mmGetPosts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPosts.mock
}

// Set uses given function f to mock the Storage.GetPosts method
func (mmGetPosts *mStorageMockGetPosts) Set(f func(ctx context.Context) (ppa1 []*model.Post, err error)) *StorageMock {
	if mmGetPosts.defaultExpectation != nil {
		mmGetPosts.mock.t.Fatalf("Default expectation is already set for the Storage.GetPosts method")
	}

	if len(mmGetPosts.expectations) > 0 {
		mmGetPosts.mock.t.Fatalf("Some expectations are already set for the Storage.GetPosts method")
	}

	mmGetPosts.mock.funcGetPosts = f
	mmGetPosts.mock.funcGetPostsOrigin = minimock.CallerInfo(1)
	return mmGetPosts.mock
}

// When sets expectation for the Storage.GetPosts which will trigger the result defined by the following
// Then helper
func (mmGetPosts *mStorageMockGetPosts) When(ctx context.Context) *StorageMockGetPostsExpectation {
	if mmGetPosts.mock.funcGetPosts != nil {
		mmGetPosts.mock.t.Fatalf("StorageMock.GetPosts mock is already set by Set")
	}

	expectation := &StorageMockGetPostsExpectation{
		mock:               mmGetPosts.mock,
		params:             &StorageMockGetPostsParams{ctx},
		expectationOrigins: StorageMockGetPostsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPosts.expectations = append(mmGetPosts.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPosts return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPostsExpectation) Then(ppa1 []*model.Post, err error) *StorageMock {
	e.results = &StorageMockGetPostsResults{ppa1, err}
	return e.mock
}

// Times sets number of times Storage.GetPosts should be invoked
func (mmGetPosts *mStorageMockGetPosts) Times(n uint64) *mStorageMockGetPosts {
	if n == 0 {
		mmGetPosts.mock.t.Fatalf("Times of StorageMock.GetPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPosts.expectedInvocations, n)
	mmGetPosts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPosts
}

func (mmGetPosts *mStorageMockGetPosts) invocationsDone() bool {
	if len(mmGetPosts.expectations) == 0 && mmGetPosts.defaultExpectation == nil && mmGetPosts.mock.funcGetPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPosts.mock.afterGetPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPosts implements mm_storage.Storage
func (mmGetPosts *StorageMock) GetPosts(ctx context.Context) (ppa1 []*model.Post, err error) {
	mm_atomic.AddUint64(&mmGetPosts.beforeGetPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPosts.afterGetPostsCounter, 1)

	mmGetPosts.t.Helper()

	if mmGetPosts.inspectFuncGetPosts != nil {
		mmGetPosts.inspectFuncGetPosts(ctx)
	}

	mm_params := StorageMockGetPostsParams{ctx}

	// Record call args
	mmGetPosts.GetPostsMock.mutex.Lock()
	mmGetPosts.GetPostsMock.callArgs = append(mmGetPosts.GetPostsMock.callArgs, &mm_params)
	mmGetPosts.GetPostsMock.mutex.Unlock()

	for _, e := range mmGetPosts.GetPostsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetPosts.GetPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPosts.GetPostsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPosts.GetPostsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPosts.GetPostsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetPostsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPosts.t.Errorf("StorageMock.GetPosts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPosts.GetPostsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPosts.t.Errorf("StorageMock.GetPosts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPosts.GetPostsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPosts.GetPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPosts.t.Fatal("No results are set for the StorageMock.GetPosts")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetPosts.funcGetPosts != nil {
		return mmGetPosts.funcGetPosts(ctx)
	}
	mmGetPosts.t.Fatalf("Unexpected call to StorageMock.GetPosts. %v", ctx)
	return
}

// GetPostsAfterCounter returns a count of finished StorageMock.GetPosts invocations
func (mmGetPosts *StorageMock) GetPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.afterGetPostsCounter)
}

// GetPostsBeforeCounter returns a count of StorageMock.GetPosts invocations
func (mmGetPosts *StorageMock) GetPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPosts.beforeGetPostsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPosts *mStorageMockGetPosts) Calls() []*StorageMockGetPostsParams {
	mmGetPosts.mutex.RLock()

	argCopy := make([]*StorageMockGetPostsParams, len(mmGetPosts.callArgs))
	copy(argCopy, mmGetPosts.callArgs)

	mmGetPosts.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostsDone returns true if the count of the GetPosts invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPostsDone() bool {
	if m.GetPostsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostsMock.invocationsDone()
}

// MinimockGetPostsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPostsInspect() {
	for _, e := range m.GetPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPosts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPostsCounter := mm_atomic.LoadUint64(&m.afterGetPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostsMock.defaultExpectation != nil && afterGetPostsCounter < 1 {
		if m.GetPostsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetPosts at\n%s", m.GetPostsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPosts at\n%s with params: %#v", m.GetPostsMock.defaultExpectation.expectationOrigins.origin, *m.GetPostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPosts != nil && afterGetPostsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetPosts at\n%s", m.funcGetPostsOrigin)
	}

	if !m.GetPostsMock.invocationsDone() && afterGetPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetPosts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostsMock.expectedInvocations), m.GetPostsMock.expectedInvocationsOrigin, afterGetPostsCounter)
	}
}

type mStorageMockGetReplies struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetRepliesExpectation
	expectations       []*StorageMockGetRepliesExpectation

	callArgs []*StorageMockGetRepliesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetRepliesExpectation specifies expectation struct of the Storage.GetReplies
type StorageMockGetRepliesExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetRepliesParams
	paramPtrs          *StorageMockGetRepliesParamPtrs
	expectationOrigins StorageMockGetRepliesExpectationOrigins
	results            *StorageMockGetRepliesResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetRepliesParams contains parameters of the Storage.GetReplies
type StorageMockGetRepliesParams struct {
	ctx      context.Context
	parentID string
	limit    int
	offset   int
}

// StorageMockGetRepliesParamPtrs contains pointers to parameters of the Storage.GetReplies
type StorageMockGetRepliesParamPtrs struct {
	ctx      *context.Context
	parentID *string
	limit    *int
	offset   *int
}

// StorageMockGetRepliesResults contains results of the Storage.GetReplies
type StorageMockGetRepliesResults struct {
	cpa1 []*model.Comment
	err  error
}

// StorageMockGetRepliesOrigins contains origins of expectations of the Storage.GetReplies
type StorageMockGetRepliesExpectationOrigins struct {
	origin         string
	originCtx      string
	originParentID string
	originLimit    string
	originOffset   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReplies *mStorageMockGetReplies) Optional() *mStorageMockGetReplies {
	mmGetReplies.optional = true
	return mmGetReplies
}

// Expect sets up expected params for Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) Expect(ctx context.Context, parentID string, limit int, offset int) *mStorageMockGetReplies {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	if mmGetReplies.defaultExpectation == nil {
		mmGetReplies.defaultExpectation = &StorageMockGetRepliesExpectation{}
	}

	if mmGetReplies.defaultExpectation.paramPtrs != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by ExpectParams functions")
	}

	mmGetReplies.defaultExpectation.params = &StorageMockGetRepliesParams{ctx, parentID, limit, offset}
	mmGetReplies.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReplies.expectations {
		if minimock.Equal(e.params, mmGetReplies.defaultExpectation.params) {
			mmGetReplies.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReplies.defaultExpectation.params)
		}
	}

	return mmGetReplies
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) ExpectCtxParam1(ctx context.Context) *mStorageMockGetReplies {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	if mmGetReplies.defaultExpectation == nil {
		mmGetReplies.defaultExpectation = &StorageMockGetRepliesExpectation{}
	}

	if mmGetReplies.defaultExpectation.params != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Expect")
	}

	if mmGetReplies.defaultExpectation.paramPtrs == nil {
		mmGetReplies.defaultExpectation.paramPtrs = &StorageMockGetRepliesParamPtrs{}
	}
	mmGetReplies.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReplies.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReplies
}

// ExpectParentIDParam2 sets up expected param parentID for Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) ExpectParentIDParam2(parentID string) *mStorageMockGetReplies {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	if mmGetReplies.defaultExpectation == nil {
		mmGetReplies.defaultExpectation = &StorageMockGetRepliesExpectation{}
	}

	if mmGetReplies.defaultExpectation.params != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Expect")
	}

	if mmGetReplies.defaultExpectation.paramPtrs == nil {
		mmGetReplies.defaultExpectation.paramPtrs = &StorageMockGetRepliesParamPtrs{}
	}
	mmGetReplies.defaultExpectation.paramPtrs.parentID = &parentID
	mmGetReplies.defaultExpectation.expectationOrigins.originParentID = minimock.CallerInfo(1)

	return mmGetReplies
}

// ExpectLimitParam3 sets up expected param limit for Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) ExpectLimitParam3(limit int) *mStorageMockGetReplies {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	if mmGetReplies.defaultExpectation == nil {
		mmGetReplies.defaultExpectation = &StorageMockGetRepliesExpectation{}
	}

	if mmGetReplies.defaultExpectation.params != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Expect")
	}

	if mmGetReplies.defaultExpectation.paramPtrs == nil {
		mmGetReplies.defaultExpectation.paramPtrs = &StorageMockGetRepliesParamPtrs{}
	}
	mmGetReplies.defaultExpectation.paramPtrs.limit = &limit
	mmGetReplies.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetReplies
}

// ExpectOffsetParam4 sets up expected param offset for Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) ExpectOffsetParam4(offset int) *mStorageMockGetReplies {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	if mmGetReplies.defaultExpectation == nil {
		mmGetReplies.defaultExpectation = &StorageMockGetRepliesExpectation{}
	}

	if mmGetReplies.defaultExpectation.params != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Expect")
	}

	if mmGetReplies.defaultExpectation.paramPtrs == nil {
		mmGetReplies.defaultExpectation.paramPtrs = &StorageMockGetRepliesParamPtrs{}
	}
	mmGetReplies.defaultExpectation.paramPtrs.offset = &offset
	mmGetReplies.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetReplies
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) Inspect(f func(ctx context.Context, parentID string, limit int, offset int)) *mStorageMockGetReplies {
	if mmGetReplies.mock.inspectFuncGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("Inspect function is already set for StorageMock.GetReplies")
	}

	mmGetReplies.mock.inspectFuncGetReplies = f

	return mmGetReplies
}

// Return sets up results that will be returned by Storage.GetReplies
func (mmGetReplies *mStorageMockGetReplies) Return(cpa1 []*model.Comment, err error) *StorageMock {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	if mmGetReplies.defaultExpectation == nil {
		mmGetReplies.defaultExpectation = &StorageMockGetRepliesExpectation{mock: mmGetReplies.mock}
	}
	mmGetReplies.defaultExpectation.results = &StorageMockGetRepliesResults{cpa1, err}
	mmGetReplies.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReplies.mock
}

// Set uses given function f to mock the Storage.GetReplies method
func (mmGetReplies *mStorageMockGetReplies) Set(f func(ctx context.Context, parentID string, limit int, offset int) (cpa1 []*model.Comment, err error)) *StorageMock {
	if mmGetReplies.defaultExpectation != nil {
		mmGetReplies.mock.t.Fatalf("Default expectation is already set for the Storage.GetReplies method")
	}

	if len(mmGetReplies.expectations) > 0 {
		mmGetReplies.mock.t.Fatalf("Some expectations are already set for the Storage.GetReplies method")
	}

	mmGetReplies.mock.funcGetReplies = f
	mmGetReplies.mock.funcGetRepliesOrigin = minimock.CallerInfo(1)
	return mmGetReplies.mock
}

// When sets expectation for the Storage.GetReplies which will trigger the result defined by the following
// Then helper
func (mmGetReplies *mStorageMockGetReplies) When(ctx context.Context, parentID string, limit int, offset int) *StorageMockGetRepliesExpectation {
	if mmGetReplies.mock.funcGetReplies != nil {
		mmGetReplies.mock.t.Fatalf("StorageMock.GetReplies mock is already set by Set")
	}

	expectation := &StorageMockGetRepliesExpectation{
		mock:               mmGetReplies.mock,
		params:             &StorageMockGetRepliesParams{ctx, parentID, limit, offset},
		expectationOrigins: StorageMockGetRepliesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReplies.expectations = append(mmGetReplies.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetReplies return parameters for the expectation previously defined by the When method
func (e *StorageMockGetRepliesExpectation) Then(cpa1 []*model.Comment, err error) *StorageMock {
	e.results = &StorageMockGetRepliesResults{cpa1, err}
	return e.mock
}

// Times sets number of times Storage.GetReplies should be invoked
func (mmGetReplies *mStorageMockGetReplies) Times(n uint64) *mStorageMockGetReplies {
	if n == 0 {
		mmGetReplies.mock.t.Fatalf("Times of StorageMock.GetReplies mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReplies.expectedInvocations, n)
	mmGetReplies.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReplies
}

func (mmGetReplies *mStorageMockGetReplies) invocationsDone() bool {
	if len(mmGetReplies.expectations) == 0 && mmGetReplies.defaultExpectation == nil && mmGetReplies.mock.funcGetReplies == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReplies.mock.afterGetRepliesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReplies.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReplies implements mm_storage.Storage
func (mmGetReplies *StorageMock) GetReplies(ctx context.Context, parentID string, limit int, offset int) (cpa1 []*model.Comment, err error) {
	mm_atomic.AddUint64(&mmGetReplies.beforeGetRepliesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReplies.afterGetRepliesCounter, 1)

	mmGetReplies.t.Helper()

	if mmGetReplies.inspectFuncGetReplies != nil {
		mmGetReplies.inspectFuncGetReplies(ctx, parentID, limit, offset)
	}

	mm_params := StorageMockGetRepliesParams{ctx, parentID, limit, offset}

	// Record call args
	mmGetReplies.GetRepliesMock.mutex.Lock()
	mmGetReplies.GetRepliesMock.callArgs = append(mmGetReplies.GetRepliesMock.callArgs, &mm_params)
	mmGetReplies.GetRepliesMock.mutex.Unlock()

	for _, e := range mmGetReplies.GetRepliesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetReplies.GetRepliesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReplies.GetRepliesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReplies.GetRepliesMock.defaultExpectation.params
		mm_want_ptrs := mmGetReplies.GetRepliesMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetRepliesParams{ctx, parentID, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReplies.t.Errorf("StorageMock.GetReplies got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReplies.GetRepliesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.parentID != nil && !minimock.Equal(*mm_want_ptrs.parentID, mm_got.parentID) {
				mmGetReplies.t.Errorf("StorageMock.GetReplies got unexpected parameter parentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReplies.GetRepliesMock.defaultExpectation.expectationOrigins.originParentID, *mm_want_ptrs.parentID, mm_got.parentID, minimock.Diff(*mm_want_ptrs.parentID, mm_got.parentID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetReplies.t.Errorf("StorageMock.GetReplies got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReplies.GetRepliesMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetReplies.t.Errorf("StorageMock.GetReplies got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReplies.GetRepliesMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReplies.t.Errorf("StorageMock.GetReplies got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReplies.GetRepliesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReplies.GetRepliesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReplies.t.Fatal("No results are set for the StorageMock.GetReplies")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetReplies.funcGetReplies != nil {
		return mmGetReplies.funcGetReplies(ctx, parentID, limit, offset)
	}
	mmGetReplies.t.Fatalf("Unexpected call to StorageMock.GetReplies. %v %v %v %v", ctx, parentID, limit, offset)
	return
}

// GetRepliesAfterCounter returns a count of finished StorageMock.GetReplies invocations
func (mmGetReplies *StorageMock) GetRepliesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReplies.afterGetRepliesCounter)
}

// GetRepliesBeforeCounter returns a count of StorageMock.GetReplies invocations
func (mmGetReplies *StorageMock) GetRepliesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReplies.beforeGetRepliesCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetReplies.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReplies *mStorageMockGetReplies) Calls() []*StorageMockGetRepliesParams {
	mmGetReplies.mutex.RLock()

	argCopy := make([]*StorageMockGetRepliesParams, len(mmGetReplies.callArgs))
	copy(argCopy, mmGetReplies.callArgs)

	mmGetReplies.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepliesDone returns true if the count of the GetReplies invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetRepliesDone() bool {
	if m.GetRepliesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepliesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepliesMock.invocationsDone()
}

// MinimockGetRepliesInspect logs each unmet expectation
func (m *StorageMock) MinimockGetRepliesInspect() {
	for _, e := range m.GetRepliesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetReplies at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepliesCounter := mm_atomic.LoadUint64(&m.afterGetRepliesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepliesMock.defaultExpectation != nil && afterGetRepliesCounter < 1 {
		if m.GetRepliesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetReplies at\n%s", m.GetRepliesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetReplies at\n%s with params: %#v", m.GetRepliesMock.defaultExpectation.expectationOrigins.origin, *m.GetRepliesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReplies != nil && afterGetRepliesCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetReplies at\n%s", m.funcGetRepliesOrigin)
	}

	if !m.GetRepliesMock.invocationsDone() && afterGetRepliesCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetReplies at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepliesMock.expectedInvocations), m.GetRepliesMock.expectedInvocationsOrigin, afterGetRepliesCounter)
	}
}

type mStorageMockToggleComments struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockToggleCommentsExpectation
	expectations       []*StorageMockToggleCommentsExpectation

	callArgs []*StorageMockToggleCommentsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockToggleCommentsExpectation specifies expectation struct of the Storage.ToggleComments
type StorageMockToggleCommentsExpectation struct {
	mock               *StorageMock
	params             *StorageMockToggleCommentsParams
	paramPtrs          *StorageMockToggleCommentsParamPtrs
	expectationOrigins StorageMockToggleCommentsExpectationOrigins
	results            *StorageMockToggleCommentsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockToggleCommentsParams contains parameters of the Storage.ToggleComments
type StorageMockToggleCommentsParams struct {
	ctx     context.Context
	postID  string
	enabled bool
	author  string
}

// StorageMockToggleCommentsParamPtrs contains pointers to parameters of the Storage.ToggleComments
type StorageMockToggleCommentsParamPtrs struct {
	ctx     *context.Context
	postID  *string
	enabled *bool
	author  *string
}

// StorageMockToggleCommentsResults contains results of the Storage.ToggleComments
type StorageMockToggleCommentsResults struct {
	pp1 *model.Post
	err error
}

// StorageMockToggleCommentsOrigins contains origins of expectations of the Storage.ToggleComments
type StorageMockToggleCommentsExpectationOrigins struct {
	origin        string
	originCtx     string
	originPostID  string
	originEnabled string
	originAuthor  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToggleComments *mStorageMockToggleComments) Optional() *mStorageMockToggleComments {
	mmToggleComments.optional = true
	return mmToggleComments
}

// Expect sets up expected params for Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) Expect(ctx context.Context, postID string, enabled bool, author string) *mStorageMockToggleComments {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	if mmToggleComments.defaultExpectation == nil {
		mmToggleComments.defaultExpectation = &StorageMockToggleCommentsExpectation{}
	}

	if mmToggleComments.defaultExpectation.paramPtrs != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by ExpectParams functions")
	}

	mmToggleComments.defaultExpectation.params = &StorageMockToggleCommentsParams{ctx, postID, enabled, author}
	mmToggleComments.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToggleComments.expectations {
		if minimock.Equal(e.params, mmToggleComments.defaultExpectation.params) {
			mmToggleComments.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToggleComments.defaultExpectation.params)
		}
	}

	return mmToggleComments
}

// ExpectCtxParam1 sets up expected param ctx for Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) ExpectCtxParam1(ctx context.Context) *mStorageMockToggleComments {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	if mmToggleComments.defaultExpectation == nil {
		mmToggleComments.defaultExpectation = &StorageMockToggleCommentsExpectation{}
	}

	if mmToggleComments.defaultExpectation.params != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Expect")
	}

	if mmToggleComments.defaultExpectation.paramPtrs == nil {
		mmToggleComments.defaultExpectation.paramPtrs = &StorageMockToggleCommentsParamPtrs{}
	}
	mmToggleComments.defaultExpectation.paramPtrs.ctx = &ctx
	mmToggleComments.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmToggleComments
}

// ExpectPostIDParam2 sets up expected param postID for Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) ExpectPostIDParam2(postID string) *mStorageMockToggleComments {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	if mmToggleComments.defaultExpectation == nil {
		mmToggleComments.defaultExpectation = &StorageMockToggleCommentsExpectation{}
	}

	if mmToggleComments.defaultExpectation.params != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Expect")
	}

	if mmToggleComments.defaultExpectation.paramPtrs == nil {
		mmToggleComments.defaultExpectation.paramPtrs = &StorageMockToggleCommentsParamPtrs{}
	}
	mmToggleComments.defaultExpectation.paramPtrs.postID = &postID
	mmToggleComments.defaultExpectation.expectationOrigins.originPostID = minimock.CallerInfo(1)

	return mmToggleComments
}

// ExpectEnabledParam3 sets up expected param enabled for Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) ExpectEnabledParam3(enabled bool) *mStorageMockToggleComments {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	if mmToggleComments.defaultExpectation == nil {
		mmToggleComments.defaultExpectation = &StorageMockToggleCommentsExpectation{}
	}

	if mmToggleComments.defaultExpectation.params != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Expect")
	}

	if mmToggleComments.defaultExpectation.paramPtrs == nil {
		mmToggleComments.defaultExpectation.paramPtrs = &StorageMockToggleCommentsParamPtrs{}
	}
	mmToggleComments.defaultExpectation.paramPtrs.enabled = &enabled
	mmToggleComments.defaultExpectation.expectationOrigins.originEnabled = minimock.CallerInfo(1)

	return mmToggleComments
}

// ExpectAuthorParam4 sets up expected param author for Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) ExpectAuthorParam4(author string) *mStorageMockToggleComments {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	if mmToggleComments.defaultExpectation == nil {
		mmToggleComments.defaultExpectation = &StorageMockToggleCommentsExpectation{}
	}

	if mmToggleComments.defaultExpectation.params != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Expect")
	}

	if mmToggleComments.defaultExpectation.paramPtrs == nil {
		mmToggleComments.defaultExpectation.paramPtrs = &StorageMockToggleCommentsParamPtrs{}
	}
	mmToggleComments.defaultExpectation.paramPtrs.author = &author
	mmToggleComments.defaultExpectation.expectationOrigins.originAuthor = minimock.CallerInfo(1)

	return mmToggleComments
}

// Inspect accepts an inspector function that has same arguments as the Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) Inspect(f func(ctx context.Context, postID string, enabled bool, author string)) *mStorageMockToggleComments {
	if mmToggleComments.mock.inspectFuncToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("Inspect function is already set for StorageMock.ToggleComments")
	}

	mmToggleComments.mock.inspectFuncToggleComments = f

	return mmToggleComments
}

// Return sets up results that will be returned by Storage.ToggleComments
func (mmToggleComments *mStorageMockToggleComments) Return(pp1 *model.Post, err error) *StorageMock {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	if mmToggleComments.defaultExpectation == nil {
		mmToggleComments.defaultExpectation = &StorageMockToggleCommentsExpectation{mock: mmToggleComments.mock}
	}
	mmToggleComments.defaultExpectation.results = &StorageMockToggleCommentsResults{pp1, err}
	mmToggleComments.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToggleComments.mock
}

// Set uses given function f to mock the Storage.ToggleComments method
func (mmToggleComments *mStorageMockToggleComments) Set(f func(ctx context.Context, postID string, enabled bool, author string) (pp1 *model.Post, err error)) *StorageMock {
	if mmToggleComments.defaultExpectation != nil {
		mmToggleComments.mock.t.Fatalf("Default expectation is already set for the Storage.ToggleComments method")
	}

	if len(mmToggleComments.expectations) > 0 {
		mmToggleComments.mock.t.Fatalf("Some expectations are already set for the Storage.ToggleComments method")
	}

	mmToggleComments.mock.funcToggleComments = f
	mmToggleComments.mock.funcToggleCommentsOrigin = minimock.CallerInfo(1)
	return mmToggleComments.mock
}

// When sets expectation for the Storage.ToggleComments which will trigger the result defined by the following
// Then helper
func (mmToggleComments *mStorageMockToggleComments) When(ctx context.Context, postID string, enabled bool, author string) *StorageMockToggleCommentsExpectation {
	if mmToggleComments.mock.funcToggleComments != nil {
		mmToggleComments.mock.t.Fatalf("StorageMock.ToggleComments mock is already set by Set")
	}

	expectation := &StorageMockToggleCommentsExpectation{
		mock:               mmToggleComments.mock,
		params:             &StorageMockToggleCommentsParams{ctx, postID, enabled, author},
		expectationOrigins: StorageMockToggleCommentsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToggleComments.expectations = append(mmToggleComments.expectations, expectation)
	return expectation
}

// Then sets up Storage.ToggleComments return parameters for the expectation previously defined by the When method
func (e *StorageMockToggleCommentsExpectation) Then(pp1 *model.Post, err error) *StorageMock {
	e.results = &StorageMockToggleCommentsResults{pp1, err}
	return e.mock
}

// Times sets number of times Storage.ToggleComments should be invoked
func (mmToggleComments *mStorageMockToggleComments) Times(n uint64) *mStorageMockToggleComments {
	if n == 0 {
		mmToggleComments.mock.t.Fatalf("Times of StorageMock.ToggleComments mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToggleComments.expectedInvocations, n)
	mmToggleComments.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToggleComments
}

func (mmToggleComments *mStorageMockToggleComments) invocationsDone() bool {
	if len(mmToggleComments.expectations) == 0 && mmToggleComments.defaultExpectation == nil && mmToggleComments.mock.funcToggleComments == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToggleComments.mock.afterToggleCommentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToggleComments.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToggleComments implements mm_storage.Storage
func (mmToggleComments *StorageMock) ToggleComments(ctx context.Context, postID string, enabled bool, author string) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmToggleComments.beforeToggleCommentsCounter, 1)
	defer mm_atomic.AddUint64(&mmToggleComments.afterToggleCommentsCounter, 1)

	mmToggleComments.t.Helper()

	if mmToggleComments.inspectFuncToggleComments != nil {
		mmToggleComments.inspectFuncToggleComments(ctx, postID, enabled, author)
	}

	mm_params := StorageMockToggleCommentsParams{ctx, postID, enabled, author}

	// Record call args
	mmToggleComments.ToggleCommentsMock.mutex.Lock()
	mmToggleComments.ToggleCommentsMock.callArgs = append(mmToggleComments.ToggleCommentsMock.callArgs, &mm_params)
	mmToggleComments.ToggleCommentsMock.mutex.Unlock()

	for _, e := range mmToggleComments.ToggleCommentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmToggleComments.ToggleCommentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToggleComments.ToggleCommentsMock.defaultExpectation.Counter, 1)
		mm_want := mmToggleComments.ToggleCommentsMock.defaultExpectation.params
		mm_want_ptrs := mmToggleComments.ToggleCommentsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockToggleCommentsParams{ctx, postID, enabled, author}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmToggleComments.t.Errorf("StorageMock.ToggleComments got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleComments.ToggleCommentsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postID != nil && !minimock.Equal(*mm_want_ptrs.postID, mm_got.postID) {
				mmToggleComments.t.Errorf("StorageMock.ToggleComments got unexpected parameter postID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleComments.ToggleCommentsMock.defaultExpectation.expectationOrigins.originPostID, *mm_want_ptrs.postID, mm_got.postID, minimock.Diff(*mm_want_ptrs.postID, mm_got.postID))
			}

			if mm_want_ptrs.enabled != nil && !minimock.Equal(*mm_want_ptrs.enabled, mm_got.enabled) {
				mmToggleComments.t.Errorf("StorageMock.ToggleComments got unexpected parameter enabled, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleComments.ToggleCommentsMock.defaultExpectation.expectationOrigins.originEnabled, *mm_want_ptrs.enabled, mm_got.enabled, minimock.Diff(*mm_want_ptrs.enabled, mm_got.enabled))
			}

			if mm_want_ptrs.author != nil && !minimock.Equal(*mm_want_ptrs.author, mm_got.author) {
				mmToggleComments.t.Errorf("StorageMock.ToggleComments got unexpected parameter author, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToggleComments.ToggleCommentsMock.defaultExpectation.expectationOrigins.originAuthor, *mm_want_ptrs.author, mm_got.author, minimock.Diff(*mm_want_ptrs.author, mm_got.author))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToggleComments.t.Errorf("StorageMock.ToggleComments got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToggleComments.ToggleCommentsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToggleComments.ToggleCommentsMock.defaultExpectation.results
		if mm_results == nil {
			mmToggleComments.t.Fatal("No results are set for the StorageMock.ToggleComments")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmToggleComments.funcToggleComments != nil {
		return mmToggleComments.funcToggleComments(ctx, postID, enabled, author)
	}
	mmToggleComments.t.Fatalf("Unexpected call to StorageMock.ToggleComments. %v %v %v %v", ctx, postID, enabled, author)
	return
}

// ToggleCommentsAfterCounter returns a count of finished StorageMock.ToggleComments invocations
func (mmToggleComments *StorageMock) ToggleCommentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleComments.afterToggleCommentsCounter)
}

// ToggleCommentsBeforeCounter returns a count of StorageMock.ToggleComments invocations
func (mmToggleComments *StorageMock) ToggleCommentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToggleComments.beforeToggleCommentsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ToggleComments.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToggleComments *mStorageMockToggleComments) Calls() []*StorageMockToggleCommentsParams {
	mmToggleComments.mutex.RLock()

	argCopy := make([]*StorageMockToggleCommentsParams, len(mmToggleComments.callArgs))
	copy(argCopy, mmToggleComments.callArgs)

	mmToggleComments.mutex.RUnlock()

	return argCopy
}

// MinimockToggleCommentsDone returns true if the count of the ToggleComments invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockToggleCommentsDone() bool {
	if m.ToggleCommentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToggleCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToggleCommentsMock.invocationsDone()
}

// MinimockToggleCommentsInspect logs each unmet expectation
func (m *StorageMock) MinimockToggleCommentsInspect() {
	for _, e := range m.ToggleCommentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ToggleComments at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToggleCommentsCounter := mm_atomic.LoadUint64(&m.afterToggleCommentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToggleCommentsMock.defaultExpectation != nil && afterToggleCommentsCounter < 1 {
		if m.ToggleCommentsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ToggleComments at\n%s", m.ToggleCommentsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ToggleComments at\n%s with params: %#v", m.ToggleCommentsMock.defaultExpectation.expectationOrigins.origin, *m.ToggleCommentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToggleComments != nil && afterToggleCommentsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ToggleComments at\n%s", m.funcToggleCommentsOrigin)
	}

	if !m.ToggleCommentsMock.invocationsDone() && afterToggleCommentsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ToggleComments at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToggleCommentsMock.expectedInvocations), m.ToggleCommentsMock.expectedInvocationsOrigin, afterToggleCommentsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCommentInspect()

			m.MinimockCreatePostInspect()

			m.MinimockGetCommentsByPostIDInspect()

			m.MinimockGetPostByIDInspect()

			m.MinimockGetPostsInspect()

			m.MinimockGetRepliesInspect()

			m.MinimockToggleCommentsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCommentDone() &&
		m.MinimockCreatePostDone() &&
		m.MinimockGetCommentsByPostIDDone() &&
		m.MinimockGetPostByIDDone() &&
		m.MinimockGetPostsDone() &&
		m.MinimockGetRepliesDone() &&
		m.MinimockToggleCommentsDone()
}
